<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Q&A Community</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/4712/4712108.png">
    <link rel="stylesheet" href="community.css?v=5.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <script>
        // Apply theme immediately before page renders
        const theme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', theme);
    </script>
</head>
<body data-theme="dark">
    <!-- Inline script to apply theme to body immediately -->
    <script>
        (function() {
            const theme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', theme);
        })();
    </script>
    <!-- Auth Container (Top Right) - Same as index.html -->
    <div class="auth-container">
        <span id="usernameDisplay" style="display: none; margin-right: 10px;"></span>
        
        <!-- Notification Bell -->
        <div class="notification-bell-container">
            <button id="notificationBellBtn" class="notification-bell" title="Notifications">
                <i class="fas fa-bell"></i>
                <span id="notificationBadge" class="notification-badge" style="display: none;">0</span>
            </button>
            
            <!-- Notification Dropdown -->
            <div id="notificationDropdown" class="notification-dropdown" style="display: none;">
                <div class="notification-header">
                    <h3>Notifications</h3>
                    <button id="closeNotificationBtn" class="close-notification-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="notificationList" class="notification-list">
                    <!-- Notifications will be loaded here -->
                    <div class="empty-notifications">No notifications</div>
                </div>
            </div>
        </div>
        
        <a href="auth/login" class="login-button" id="loginBtn">Login</a>
    </div>

    <!-- Main Container - Same structure as index.html -->
    <div class="container">
        <!-- Sidebar - Same as index.html -->
        <div id="chatList">
            <div class="btn-sidebar-container"></div>
            
            <!-- Infineon Logo -->
            <div class="sidebar-logo">
                <img src="image.png" alt="Infineon Logo" class="infineon-logo">
            </div>
            
            <!-- Q&A Community Button -->
            <a href="/" class="community-nav-button">
                <i class="fas fa-robot"></i> AI Chat
            </a>

            <!-- Filter By Section -->
            <div class="sidebar-section">
                <div class="section-title">Filter By</div>
                <a href="#" class="sidebar-link active" data-filter="all">All questions</a>
                <a href="#" class="sidebar-link" data-filter="my-questions">My Questions</a>
                <a href="#" class="sidebar-link" data-filter="my-answers">My Answers</a>
                <a href="#" class="sidebar-link" data-filter="pending-review">Pending review</a>
                <a href="#" class="sidebar-link" data-filter="unverified">Unverified</a>
            </div>

            <!-- Tags Section -->
            <div class="sidebar-section">
                <div class="section-title">Tags</div>
                <div id="tagsList" class="sidebar-tags-grid">
                    <span class="tags-loading">Loading tags...</span>
                </div>
            </div>

            <!-- Theme Toggle Button -->
            <div class="theme-toggle-container">
                <button id="themeToggleBtn" class="theme-toggle-btn" title="Change Theme">
                    <i class="fas fa-palette"></i>
                    <span id="themeLabel">Dark</span>
                </button>
            </div>
        </div>

        <!-- Main Content Area - Same structure as index.html #chatbox -->
        <div id="chatbox">
            <!-- Header - Same as index.html -->
            <h1 class="header1">
                <button id="toggleSidebarButton"><i class="fas fa-bars"></i></button>
                Q&A Community
            </h1>

            <!-- Content -->
            <div class="contain-overflow">
                <div class="content-wrapper">
                    <!-- Header Section -->
                    <div class="page-header">
                        <div class="header-top">
                            <h2>Questions</h2>
                            <div class="header-search">
                                <input type="text" id="headerSearch" placeholder="Search questions or #tag...">
                            </div>
                            <button class="btn-ask-large" onclick="window.location.href='/create_question.html'">Create Question</button>
                        </div>
                    </div>

                    <!-- Tabs & Sort -->
                    <div class="tabs-section">
                        <div class="tabs">
                            <button class="tab active" onclick="filterByTab('all', event)">Newest</button>
                            <button class="tab" onclick="filterByTab('score', event)">Score</button>
                            <button class="tab" onclick="filterByTab('views', event)">Views</button>
                            <button class="tab" onclick="filterByTab('verified', event)">Verified</button>
                        </div>
                    </div>

                    <!-- Questions List -->
                    <div class="questions-list" id="questionsList">
                        <div class="loading-state">
                            <div class="spinner"></div>
                            <p>Loading questions...</p>
                        </div>
                    </div>
                </div>

                <!-- Right Sidebar -->
                <aside class="right-sidebar">
                    <div class="info-box">
                        <div class="box-title">Community Stats</div>
                        <div class="stat-row">
                            <span>Total Questions</span>
                            <span class="stat-value" id="totalQuestions"></span>
                        </div>
                        <div class="stat-row">
                            <span>Verified Answers</span>
                            <span class="stat-value" id="verifiedCount"></span>
                        </div>
                    </div>

                    <div class="info-box">
                        <div class="box-title">Hot Questions</div>
                        <div class="mini-list" id="sidebarHotQuestions">
                            <a href="#" class="mini-link">How to optimize database queries?</a>
                            <a href="#" class="mini-link">Best practices for API design</a>
                            <a href="#" class="mini-link">JavaScript async/await patterns</a>
                        </div>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <script>
        let allQuestions = [];
        let allQuestionsForHotQuestions = []; // Store ALL questions for Hot Questions (never filtered)
        let currentFilter = 'all';
        let currentSort = 'newest';
        let selectedTags = [];
        let currentUserId = null;
        let currentUsername = null;
        let totalQuestionCount = 0; // Store total count from 'all' filter
        
        // Pagination variables
        let currentPage = 1;
        let totalPages = 1;
        const questionsPerPage = 20;

        // ===== URL Params Functions =====
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            const tagsParam = params.get('tags');
            return {
                filter: params.get('filter') || 'all',
                sort: params.get('sort') || 'newest',
                page: parseInt(params.get('page')) || 1,
                tags: tagsParam ? tagsParam.split(',') : []
            };
        }

        function updateUrlParams() {
            const params = new URLSearchParams();
            if (currentFilter !== 'all') params.set('filter', currentFilter);
            if (currentSort !== 'newest') params.set('sort', currentSort);
            if (currentPage > 1) params.set('page', currentPage);
            if (selectedTags.length > 0) params.set('tags', selectedTags.join(','));
            
            const newUrl = params.toString() 
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;
            
            window.history.replaceState({}, '', newUrl);
        }

        function restoreFromUrlParams() {
            const params = getUrlParams();
            currentFilter = params.filter;
            currentSort = params.sort;
            currentPage = params.page;
            selectedTags = params.tags; // Restore selected tags
            
            // Update sidebar active state
            document.querySelectorAll('.sidebar-link[data-filter]').forEach(link => {
                link.classList.toggle('active', link.dataset.filter === currentFilter);
            });
            
            // Update tab active state - remove all active first, then add to correct one
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            
            document.querySelectorAll('.tab').forEach(tab => {
                const tabType = tab.textContent.toLowerCase();
                if (currentFilter === 'verified' && tabType === 'verified') {
                    tab.classList.add('active');
                } else if (currentFilter !== 'verified') {
                    if (currentSort === 'newest' && tabType === 'newest') tab.classList.add('active');
                    else if (currentSort === 'score' && tabType === 'score') tab.classList.add('active');
                    else if (currentSort === 'views' && tabType === 'views') tab.classList.add('active');
                }
            });
        }
        
        // Apply saved tags after hot tags are loaded
        function applySelectedTagsToUI() {
            if (selectedTags.length === 0) return;
            
            document.querySelectorAll('.sidebar-tag-item').forEach(tag => {
                if (selectedTags.includes(tag.dataset.tag)) {
                    tag.classList.add('active');
                }
            });
            
            // Re-render with tag filter
            renderQuestions();
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await getCurrentUser();
            restoreFromUrlParams(); // Restore filter/sort/page/tags from URL
            loadHotTags(); // Load hot tags immediately (no await - load in parallel)
            await loadQuestionsByFilter(currentFilter, currentPage); // Use restored values
            setupSearchListener();
            setupSidebarToggle();
            setupFilterLinks();
            setupPageRefresh();
            setupNotificationBell();
            await loadNotifications(); // Load notifications immediately on page load
            initTheme();
        });

        // Refresh data when user returns to this page from detail page
        function setupPageRefresh() {
            // Listen for page visibility changes
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    console.log('Page became visible, refreshing questions...');
                    loadAllQuestions();
                }
            });

            // Also listen for page focus
            window.addEventListener('focus', () => {
                console.log('Window focused, refreshing questions...');
                loadAllQuestions();
            });
        }

        async function getCurrentUser() {
            try {
                const res = await fetch('/auth/session');
                if (!res.ok) throw new Error('Failed to get session');
                const data = await res.json();
                
                const loginBtn = document.getElementById('loginBtn');
                const usernameDisplay = document.getElementById('usernameDisplay');
                
                if (data.loggedIn) {
                    currentUserId = data.userId || null;
                    currentUsername = data.username || null;
                    
                    if (loginBtn) {
                        loginBtn.textContent = data.isGuest ? 'Login' : 'Logout';
                        loginBtn.href = data.isGuest ? '/auth/login' : '/auth/logout';
                    }
                    
                    if (!data.isGuest && data.username && usernameDisplay) {
                        usernameDisplay.textContent = `Welcome: ${data.username}`;
                        usernameDisplay.style.display = 'inline';
                    } else if (usernameDisplay) {
                        usernameDisplay.style.display = 'none';
                    }
                } else {
                    // Not logged in, redirect to login
                    window.location.href = '/auth/login';
                    return;
                }
            } catch (e) {
                console.log('User not logged in:', e);
                window.location.href = '/auth/login';
            }
        }

        function setupNotificationBell() {
            const bellBtn = document.getElementById('notificationBellBtn');
            const dropdown = document.getElementById('notificationDropdown');
            const closeBtn = document.getElementById('closeNotificationBtn');
            const notificationList = document.getElementById('notificationList');

            if (!bellBtn) return;

            // Toggle dropdown
            bellBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (dropdown.style.display === 'none') {
                    dropdown.style.display = 'block';
                    await loadNotifications();
                } else {
                    dropdown.style.display = 'none';
                }
            });

            // Close dropdown
            closeBtn?.addEventListener('click', () => {
                dropdown.style.display = 'none';
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.notification-bell-container')) {
                    dropdown.style.display = 'none';
                }
            });
        }

        async function loadNotifications() {
            try {
                if (!currentUserId) return;

                const res = await fetch(`/api/get-notifications`);
                const data = await res.json();

                const notificationList = document.getElementById('notificationList');
                const badge = document.getElementById('notificationBadge');

                if (data.success && data.notifications && data.notifications.length > 0) {
                    // Show unread count in badge
                    const unreadCount = data.unreadCount || 0;
                    badge.textContent = unreadCount;
                    badge.style.display = unreadCount > 0 ? 'block' : 'none';

                    notificationList.innerHTML = data.notifications.map(notif => `
                        <div class="notification-item ${!notif.isRead ? 'unread' : ''}" onclick="handleNotificationClick(${notif.id}, ${notif.questionId}, ${notif.isRead})">
                            ${!notif.isRead ? '<div class="notification-unread-indicator"></div>' : ''}
                            <div class="notification-item-avatar">
                                ${notif.verifiedBy ? notif.verifiedBy.charAt(0).toUpperCase() : 'V'}
                            </div>
                            <div class="notification-item-content">
                                <div class="notification-item-title">Answer Verified</div>
                                <div class="notification-item-text">
                                    Your answer was verified by <strong>${notif.verifiedBy || 'User'}</strong> from <strong>${notif.department || 'Department'}</strong>
                                </div>
                                <div class="notification-item-meta">
                                    ${formatDate(notif.createdAt)}
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    badge.style.display = 'none';
                    notificationList.innerHTML = '<div class="empty-notifications">No notifications</div>';
                }
            } catch (e) {
                console.error('Error loading notifications:', e);
            }
        }

        async function handleNotificationClick(notificationId, questionId, isRead) {
            try {
                // Mark as read if not already read
                if (!isRead) {
                    await fetch('/api/mark-notification-read', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ notificationId })
                    });
                    
                    // Reload notifications to update badge and UI
                    await loadNotifications();
                }
                
                // Navigate to question
                window.location.href = `comment.html?id=${questionId}`;
            } catch (e) {
                console.error('Error handling notification click:', e);
                // Still navigate even if marking fails
                window.location.href = `comment.html?id=${questionId}`;
            }
        }

        function formatDate(dateStr) {
            if (!dateStr) return 'Just now';
            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins} min ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return date.toLocaleDateString();
        }

        // Sidebar Toggle Functionality (same as index.html)
        function setupSidebarToggle() {
            const toggleBtn = document.getElementById('toggleSidebarButton');
            const chatList = document.getElementById('chatList');
            const chatbox = document.getElementById('chatbox');
            const header = document.querySelector('.header1');

            // Restore sidebar state from localStorage
            if (localStorage.getItem('sidebarCollapsed') === 'true') {
                chatList.classList.add('collapsed');
                chatbox.classList.add('collapsed');
                header.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
            }

            toggleBtn.addEventListener('click', () => {
                chatList.classList.toggle('collapsed');
                chatbox.classList.toggle('collapsed');
                header.classList.toggle('collapsed');
                toggleBtn.classList.toggle('collapsed');
                localStorage.setItem('sidebarCollapsed', chatList.classList.contains('collapsed'));
            });
        }

        function setupFilterLinks() {
            document.querySelectorAll('.sidebar-link[data-filter]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('.sidebar-link[data-filter]').forEach(l => l.classList.remove('active'));
                    link.classList.add('active');
                    const filter = link.dataset.filter;
                    applyFilter(filter);
                });
            });

            // Setup tag click handlers
            document.querySelectorAll('.sidebar-tag-item').forEach(tag => {
                tag.addEventListener('click', () => {
                    tag.classList.toggle('active');
                    filterByTags();
                });
            });
        }

        function filterByTags() {
            selectedTags = Array.from(document.querySelectorAll('.sidebar-tag-item.active')).map(t => t.dataset.tag);
            console.log('Selected tags:', selectedTags);
            updateUrlParams(); // Save tags to URL
            
            // If no tags selected, reload with current filter
            if (selectedTags.length === 0) {
                loadQuestionsByFilter(currentFilter);
            } else {
                // Keep current filter and just render with tag filter
                renderQuestions();
            }
        }

        async function applyFilter(filter) {
            currentFilter = filter;
            currentPage = 1; // Reset to first page when filter changes
            updateUrlParams(); // Save to URL
            await loadQuestionsByFilter(filter);
        }

        async function loadQuestionsByFilter(filter, page = 1) {
            try {
                let url = `/api/filter-questions?type=${filter}&page=${page}&limit=${questionsPerPage}`;
                
                // Add username if user is logged in
                if (currentUsername) {
                    url += '&username=' + encodeURIComponent(currentUsername);
                }
                
                // Add sort parameter
                const sortParam = currentSort || 'newest';
                url += '&sortBy=' + sortParam;
                
                const res = await fetch(url);
                const data = await res.json();
                
                allQuestions = (data.results || []).map((q, idx) => ({
                    ...q,
                    id: q.id || idx,
                    views: q.views || 0,
                    // Keep vote_score for Hot Questions sorting
                    vote_score: q.vote_score || 0
                }));
                
                // Update pagination info
                currentPage = data.currentPage || 1;
                totalPages = data.totalPages || 1;
                totalQuestionCount = data.totalCount || allQuestions.length;
                
                // Store all questions for Hot Questions when loading 'all' questions
                if (filter === 'all' && page === 1) {
                    // For hot questions, we might want to fetch separately or use first page
                    allQuestionsForHotQuestions = [...allQuestions];
                }
                
                console.log(`Loaded ${allQuestions.length} questions with filter: ${filter} (page ${currentPage}/${totalPages}, total: ${totalQuestionCount})`);
                
                updateStats();
                renderQuestions();
                renderPagination();
                await loadHotTags();
            } catch (e) {
                console.error('Error loading filtered questions:', e);
                showEmpty();
            }
        }

        async function loadHotTags() {
            try {
                const res = await fetch('/api/hot-tags?limit=8');
                const data = await res.json();
                if (data.success && data.tags.length > 0) {
                    const tagsListDiv = document.getElementById('tagsList');
                    tagsListDiv.innerHTML = data.tags.map(t => 
                        `<span class="sidebar-tag-item" data-tag="${t.tag}">${t.tag}</span>`
                    ).join('');
                    
                    // Re-attach click handlers
                    document.querySelectorAll('.sidebar-tag-item').forEach(tag => {
                        tag.addEventListener('click', () => {
                            tag.classList.toggle('active');
                            filterByTags();
                        });
                    });
                    
                    // Apply saved tags from URL after tags are loaded
                    applySelectedTagsToUI();
                }
            } catch (e) {
                console.error('Error loading hot tags:', e);
            }
        }

        async function loadAllQuestions() {
            try {
                await loadQuestionsByFilter('all');
            } catch (e) {
                console.error('Error:', e);
                showEmpty();
            }
        }

        // Debounce utility function
        function debounce(func, wait = 300) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function setupSearchListener() {
            const searchInput = document.getElementById('headerSearch');
            
            // Debounced search - ‡∏£‡∏≠ 300ms ‡∏´‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏û‡∏¥‡∏°‡∏û‡πå
            const debouncedSearch = debounce((value) => {
                performSearch(value);
            }, 300);
            
            // Search while typing (with debounce)
            searchInput.addEventListener('input', (e) => {
                debouncedSearch(e.target.value);
            });
            
            // Immediate search on Enter
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch(searchInput.value);
            });
        }

        async function performSearch(query) {
            if (!query.trim()) {
                await loadAllQuestions();
                return;
            }
            
            try {
                // Check if search query starts with # for tag search
                if (query.trim().startsWith('#')) {
                    // Tag search
                    const tagQuery = query.trim().substring(1).toLowerCase();
                    console.log('Searching by tag:', tagQuery);
                    
                    // Load all questions if not loaded yet
                    if (allQuestions.length === 0) {
                        await loadQuestionsByFilter('all');
                    }
                    
                    // Filter by tag and store in a temporary variable to avoid mutation
                    const filtered = allQuestions.filter(q => {
                        const tags = (q.tags || []).map(t => t.toLowerCase());
                        return tags.some(t => t.includes(tagQuery));
                    });
                    
                    // Create a copy and render
                    const originalQuestions = [...allQuestions];
                    allQuestions = filtered;
                    renderQuestions();
                    
                    // Restore original questions for next search
                    setTimeout(() => {
                        if (allQuestions.length === filtered.length) {
                            allQuestions = originalQuestions;
                        }
                    }, 100);
                } else {
                    // Regular semantic search by question text
                    const res = await fetch('/api/search-verified-answers', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ question: query, threshold: 0.7, limit: 20 })
                    });
                    const data = await res.json();
                    allQuestions = (data.results || []).map((q, idx) => ({
                        ...q,
                        id: q.id || idx,
                        views: q.views || 0
                    }));
                    renderQuestions();
                }
            } catch (e) {
                console.error('Search error:', e);
                showEmpty();
            }
        }

        function filterByTab(tab, event) {
            // Update active tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            let filterChanged = false;
            
            // Map tab to filter or sort
            if (tab === 'verified') {
                // "Verified" tab should filter by verified items
                if (currentFilter !== 'verified') {
                    currentFilter = 'verified';
                    filterChanged = true;
                }
                currentSort = 'newest';
            } else {
                // Other tabs are sorting options (newest, score, views)
                currentSort = (tab === 'all') ? 'newest' : tab;
                // Keep current filter or reset to 'all'
                if (currentFilter === 'verified') {
                    currentFilter = 'all';
                    filterChanged = true;
                }
            }
            
            // Reset to page 1 when filter/sort changes
            currentPage = 1;
            updateUrlParams(); // Save to URL
            
            // Only reload if filter changed, otherwise just re-render with new sort
            if (filterChanged) {
                loadQuestionsByFilter(currentFilter, 1);
            } else {
                // For sort change, we need to reload from API since sorting is done server-side
                loadQuestionsByFilter(currentFilter, 1);
            }
        }

        function updateSort() {
            currentSort = document.getElementById('sortSelect').value;
            renderQuestions();
        }

        function updateStats() {
            // Always show total from 'all' filter, not current filtered count
            document.getElementById('totalQuestions').textContent = totalQuestionCount;
            
            // Count verified questions: self-verified OR fully verified requests (from all questions)
            const verifiedCount = allQuestionsForHotQuestions.filter(q => {
                // Self-verified
                if (q.verification_type === 'self') {
                    return true;
                }
                // Request type: must have verification_count == total_requested_depts AND > 0
                if (q.verification_type === 'request') {
                    const verificationCount = q.verification_count || 0;
                    const totalRequestedDepts = q.total_requested_depts || 0;
                    return totalRequestedDepts > 0 && verificationCount === totalRequestedDepts;
                }
                return false;
            }).length;
            
            document.getElementById('verifiedCount').textContent = verifiedCount;
            // Update Hot Questions after stats
            updateHotQuestions();
        }

        function updateHotQuestions() {
            // Always use ALL questions for Hot Questions (top 3 by score, regardless of filters)
            if (allQuestionsForHotQuestions.length === 0) return;
            
            // Sort by vote_score (descending) and get top 3
            const topQuestions = [...allQuestionsForHotQuestions]
                .sort((a, b) => {
                    const scoreA = a.vote_score || a.score || 0;
                    const scoreB = b.vote_score || b.score || 0;
                    return scoreB - scoreA;
                })
                .slice(0, 3);
            
            // Update Hot Questions list with consistent styling
            const hotQuestionsDiv = document.getElementById('sidebarHotQuestions');
            if (hotQuestionsDiv) {
                if (topQuestions.length === 0) {
                    hotQuestionsDiv.innerHTML = '<div style="color: #999; padding: 10px; text-align: center; font-size: 13px;">No questions yet</div>';
                } else {
                    hotQuestionsDiv.innerHTML = topQuestions.map((q, idx) => {
                        const scoreDisplay = q.score || 0;
                        const title = esc(q.question || q.question_title || 'Untitled');
                        return `<a href="comment.html?id=${q.id}" class="mini-link" onclick="event.stopPropagation()" style="display: flex; align-items: center; gap: 8px;" title="Score: ${scoreDisplay}"><span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</span></a>`;
                    }).join('');
                }
            }
        }

        function renderQuestions() {
            let filtered = [...allQuestions];

            // Apply tag filter only (type filter is already handled by API)
            if (selectedTags.length > 0) {
                filtered = filtered.filter(q => {
                    const qTags = (q.tags || []).map(t => t.toLowerCase());
                    // Check if question has at least one tag that matches selected tags
                    return selectedTags.some(tag => 
                        qTags.some(qTag => qTag === tag.toLowerCase())
                    );
                });
            }

            // Apply tab sort (Newest, Score, Views, Verified)
            if (currentSort === 'verified') {
                // Show verified questions: both self-verified and fully verified request types
                filtered = filtered.filter(q => {
                    // Self-verified questions
                    if (q.verification_type === 'self') {
                        return true;
                    }
                    // Request type: show only if fully verified (verification_count >= total_requested_depts)
                    if (q.verification_type === 'request') {
                        const totalDepts = q.total_requested_depts || 0;
                        const verifiedCount = q.verification_count || 0;
                        return totalDepts > 0 && verifiedCount >= totalDepts;
                    }
                    return false;
                });
            } else if (currentSort === 'score') {
                // Sort by vote_score descending (upvote/downvote only)
                filtered.sort((a, b) => {
                    const scoreA = a.vote_score || 0;
                    const scoreB = b.vote_score || 0;
                    return scoreB - scoreA;
                });
            } else if (currentSort === 'views') {
                // Sort by views descending
                filtered.sort((a, b) => (b.views || 0) - (a.views || 0));
            } else {
                // Default (newest): sort by created_at descending
                filtered.sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));
            }

            if (!filtered.length) {
                showEmpty();
                return;
            }

            document.getElementById('questionsList').innerHTML = filtered.map(q => {
                // Determine badge based on verification status
                let badgeHtml = '';
                
                // Check if question is waiting for verification (request type questions)
                if (q.verification_type === 'request') {
                    // Use total_requested_depts from backend query
                    const deptCount = q.total_requested_depts || 0;
                    const verifiedCount = q.verification_count || 0;
                    
                    if (deptCount > 0) {
                        // Has departments to verify from
                        if (verifiedCount >= deptCount) {
                            // All verified - show green badge
                            badgeHtml = `<span class="vote-badge verified-badge">‚úì Verified (${verifiedCount}/${deptCount})</span>`;
                        } else {
                            // Pending verification - show yellow badge
                            badgeHtml = `<span class="vote-badge pending-badge">‚è≥ ${verifiedCount}/${deptCount} Pending</span>`;
                        }
                    }
                } else if (q.verification_type === 'self') {
                    // For self verification, show department names
                    const deptsList = Array.isArray(q.requested_departments) 
                        ? q.requested_departments 
                        : (typeof q.requested_departments === 'string' ? q.requested_departments.split(',').map(d => d.trim()) : []);
                    
                    if (deptsList.length > 0) {
                        badgeHtml = `<span class="vote-badge verified-badge">‚úì Verified ${deptsList.join(', ')}</span>`;
                    } else {
                        badgeHtml = '<span class="vote-badge verified-badge">‚úì Verified</span>';
                    }
                }
                
                return `
                <div class="question-item" onclick="goToDetail(${q.id})">
                    <div class="vote-section">
                        <div class="vote-count">${q.vote_score || 0}</div>
                        <div>${badgeHtml}</div>
                    </div>
                    <div class="question-content">
                        <a href="comment.html?id=${q.id}" class="question-title" onclick="event.stopPropagation()">${esc(q.question || q.question_title || 'Untitled')}</a>
                        <div class="question-excerpt">${esc(stripHtml((q.answer || q.summary || '')).substring(0, 120))}</div>
                        <div class="question-tags">${(q.tags || []).map(tag => `<span class="tag-badge">${esc(tag)}</span>`).join('')}</div>
                    </div>
                    <div class="question-meta">
                        <span>${q.views || 0} views</span>
                        <div class="user-info">
                            <div class="avatar">${(q.created_by || q.user_name || 'U')[0].toUpperCase()}</div>
                            <div class="user-text">
                                <span class="username">${esc(q.created_by || q.user_name || 'Anonymous')}</span>
                                <span class="time">${formatDate(q.created_at)}</span>
                            </div>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        async function incrementView(questionId) {
            try {
                await fetch('/api/increment-view', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ questionId })
                });
                // Update local view count
                const q = allQuestions.find(q => q.id === questionId);
                if (q) q.views = (q.views || 0) + 1;
            } catch (e) {
                console.error('Error incrementing view:', e);
            }
        }

        function showEmpty() {
            document.getElementById('questionsList').innerHTML = '<div class="empty-state"><div class="empty-icon">üîç</div><p>No questions found</p></div>';
            // Clear pagination when no results
            const paginationContainer = document.getElementById('paginationContainer');
            if (paginationContainer) {
                paginationContainer.innerHTML = '';
            }
        }

        function renderPagination() {
            let paginationContainer = document.getElementById('paginationContainer');
            
            // Create pagination container if it doesn't exist
            if (!paginationContainer) {
                paginationContainer = document.createElement('div');
                paginationContainer.id = 'paginationContainer';
                paginationContainer.className = 'pagination-container';
                document.getElementById('questionsList').after(paginationContainer);
            }
            
            // Don't show pagination if only 1 page
            if (totalPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }
            
            let paginationHtml = '<div class="pagination">';
            
            // Previous button
            paginationHtml += `<button class="pagination-btn ${currentPage === 1 ? 'disabled' : ''}" 
                onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
                ‚Üê Prev
            </button>`;
            
            // Page numbers
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust start if we're near the end
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            // First page
            if (startPage > 1) {
                paginationHtml += `<button class="pagination-btn" onclick="goToPage(1)">1</button>`;
                if (startPage > 2) {
                    paginationHtml += `<span class="pagination-ellipsis">...</span>`;
                }
            }
            
            // Page numbers
            for (let i = startPage; i <= endPage; i++) {
                paginationHtml += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" 
                    onclick="goToPage(${i})">${i}</button>`;
            }
            
            // Last page
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHtml += `<span class="pagination-ellipsis">...</span>`;
                }
                paginationHtml += `<button class="pagination-btn" onclick="goToPage(${totalPages})">${totalPages}</button>`;
            }
            
            // Next button
            paginationHtml += `<button class="pagination-btn ${currentPage === totalPages ? 'disabled' : ''}" 
                onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
                Next ‚Üí
            </button>`;
            
            paginationHtml += '</div>';
            
            paginationContainer.innerHTML = paginationHtml;
        }
        
        function goToPage(page) {
            if (page < 1 || page > totalPages || page === currentPage) return;
            currentPage = page;
            updateUrlParams(); // Save to URL
            loadQuestionsByFilter(currentFilter, page);
            // Scroll to top of questions list
            document.getElementById('questionsList').scrollIntoView({ behavior: 'smooth' });
        }

        function formatDate(d) {
            if (!d) return 'unknown';
            const date = new Date(d);
            if (isNaN(date)) return 'unknown';
            const diff = Date.now() - date, m = Math.floor(diff/60000), h = Math.floor(diff/3600000), dy = Math.floor(diff/86400000);
            return m < 1 ? 'just now' : m < 60 ? m + 'm ago' : h < 24 ? h + 'h ago' : dy < 30 ? dy + 'd ago' : date.toLocaleDateString();
        }

        function esc(t) {
            if (!t) return '';
            const m = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
            return String(t).replace(/[&<>"']/g, c => m[c]);
        }

        // Extract plain text from HTML content
        function stripHtml(html) {
            if (!html) return '';
            const temp = document.createElement('div');
            temp.innerHTML = html;
            return temp.textContent || temp.innerText || '';
        }

        // Theme Toggle Functionality
        const themes = ['dark', 'light'];
        let currentTheme = localStorage.getItem('theme') || 'dark';

        function initTheme() {
            // Always read latest theme from localStorage
            currentTheme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', currentTheme);
            updateThemeLabel();
            console.log('‚úÖ initTheme: Applied theme -', currentTheme);
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', currentTheme);
            localStorage.setItem('theme', currentTheme);
            updateThemeLabel();
            console.log('‚úÖ toggleTheme: Changed to -', currentTheme);
        }

        function updateThemeLabel() {
            const label = document.getElementById('themeLabel');
            const icon = document.querySelector('#themeToggleBtn i');
            if (currentTheme === 'dark') {
                label.textContent = 'Dark';
                icon.className = 'fas fa-moon';
            } else {
                label.textContent = 'Light';
                icon.className = 'fas fa-sun';
            }
        }

        // Listen for theme changes from other pages/tabs
        window.addEventListener('storage', (e) => {
            if (e.key === 'theme') {
                currentTheme = e.newValue || 'dark';
                document.body.setAttribute('data-theme', currentTheme);
                updateThemeLabel();
            }
        });

        function goToDetail(questionId) {
            window.location.href = `comment.html?id=${questionId}`;
        }

        // Create Question Modal Functions
        function showCreateQuestionModal() {
            if (!currentUserId) {
                alert('Please login to create a question');
                window.location.href = '/auth/login';
                return;
            }
            document.getElementById('createQuestionModal').style.display = 'flex';
        }

        function closeCreateQuestionModal() {
            document.getElementById('createQuestionModal').style.display = 'none';
            document.getElementById('questionTitle').value = '';
            document.getElementById('questionBody').value = '';
            document.getElementById('questionTags').value = '';
            document.getElementById('answerBody').value = '';
            document.getElementById('selfVerifySection').style.display = 'none';
            document.getElementById('requestDepartmentsSection').style.display = 'none';
        }

        function selectVerificationType(type) {
            const selfBtn = document.getElementById('selfVerifyBtn');
            const requestBtn = document.getElementById('requestVerifyBtn');
            const selfSection = document.getElementById('selfVerifySection');
            const requestSection = document.getElementById('requestDepartmentsSection');

            if (type === 'self') {
                selfBtn.classList.add('active');
                requestBtn.classList.remove('active');
                selfSection.style.display = 'block';
                requestSection.style.display = 'none';
            } else {
                requestBtn.classList.add('active');
                selfBtn.classList.remove('active');
                requestSection.style.display = 'block';
                selfSection.style.display = 'none';
            }
        }

        async function submitQuestion() {
            const title = document.getElementById('questionTitle').value.trim();
            const body = document.getElementById('questionBody').value.trim();
            const tagsInput = document.getElementById('questionTags').value.trim();
            const selfVerifyBtn = document.getElementById('selfVerifyBtn');
            const isSelfVerify = selfVerifyBtn.classList.contains('active');

            if (!title || !body) {
                alert('Please fill in title and body');
                return;
            }

            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];

            try {
                if (isSelfVerify) {
                    // Self-verify mode: create question with answer
                    const answer = document.getElementById('answerBody').value.trim();
                    if (!answer) {
                        alert('Please provide an answer for self-verification');
                        return;
                    }

                    const response = await fetch('/api/submit-verified-answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            question: title + '\n\n' + body,
                            answer: answer,
                            tags: tags,
                            verificationType: 'self'
                        })
                    });

                    if (response.ok) {
                        alert('Question created and verified successfully!');
                        closeCreateQuestionModal();
                        await loadAllQuestions();
                    } else {
                        const error = await response.json();
                        alert(error.error || 'Failed to create question');
                    }
                } else {
                    // Request verification mode: create question and request from departments
                    const selectedDepts = Array.from(document.querySelectorAll('.dept-checkbox:checked'))
                        .map(cb => cb.value);

                    if (selectedDepts.length === 0) {
                        alert('Please select at least one department');
                        return;
                    }

                    const dueDateInput = document.getElementById('requestDueDate').value;

                    const response = await fetch('/api/submit-verified-answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            question: title + '\n\n' + body,
                            answer: 'Waiting for response from: ' + selectedDepts.join(', '),
                            tags: tags,
                            verificationType: 'request',
                            requestedDepartments: selectedDepts,
                            dueDate: dueDateInput || null
                        })
                    });

                    if (response.ok) {
                        alert('Question created! Verification request sent to selected departments.');
                        closeCreateQuestionModal();
                        await loadAllQuestions();
                    } else {
                        const error = await response.json();
                        alert(error.error || 'Failed to create question');
                    }
                }
            } catch (e) {
                console.error('Error submitting question:', e);
                alert('Failed to submit question');
            }
        }

        document.getElementById('themeToggleBtn').addEventListener('click', toggleTheme);
        initTheme();
    </script>

    <!-- Create Question Modal -->
    <div id="createQuestionModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px;">
            <span class="modal-close" onclick="closeCreateQuestionModal()">&times;</span>
            <h2 style="margin-bottom: 20px;">Create Question</h2>

            <!-- Question Title -->
            <div class="form-group">
                <label>Title <span style="color: red;">*</span></label>
                <input type="text" id="questionTitle" placeholder="Be specific and imagine you're asking a question to another person. Min 15 characters." 
                    style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;">
            </div>

            <!-- Question Body -->
            <div class="form-group" style="margin-top: 15px;">
                <label>Body <span style="color: red;">*</span></label>
                <textarea id="questionBody" rows="6" placeholder="Include all the information someone would need to answer your question. Min 120 characters."
                    style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;"></textarea>
            </div>

            <!-- Tags -->
            <div class="form-group" style="margin-top: 15px;">
                <label>Tags</label>
                <input type="text" id="questionTags" placeholder="Add up to 5 tags to describe what your question is about. Start typing to see suggestions."
                    style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;">
                <small style="color: #666;">e.g. Handler, Prober, V9300 (comma separated)</small>
            </div>

            <!-- Verification Type Selection -->
            <div class="form-group" style="margin-top: 20px;">
                <label style="font-weight: bold;">Verification Type</label>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="selfVerifyBtn" class="verification-type-btn active" onclick="selectVerificationType('self')" 
                        style="flex: 1; padding: 12px; border: 2px solid #017374; background: #017374; color: white; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        Self Verify
                    </button>
                    <button id="requestVerifyBtn" class="verification-type-btn" onclick="selectVerificationType('request')"
                        style="flex: 1; padding: 12px; border: 2px solid #ccc; background: white; color: #333; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        Request Verification from Other Departments
                    </button>
                </div>
            </div>

            <!-- Self Verify Section -->
            <div id="selfVerifySection" style="margin-top: 15px; display: block;">
                <label>Answer <span style="color: red;">*</span></label>
                <textarea id="answerBody" rows="6" placeholder="Provide your answer and verify it as correct from your department."
                    style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;"></textarea>
            </div>

            <!-- Request Departments Section -->
            <div id="requestDepartmentsSection" style="margin-top: 15px; display: none;">
                <!-- Yellow Info Bar -->
                <div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 12px 15px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 20px;">‚è≥</span>
                    <span style="color: #856404; font-weight: 500;">Your question will be marked as "‚è≥ Pending" until selected departments verify it.</span>
                </div>

                <label style="font-weight: bold;">Select Departments <span style="color: red;">*</span></label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="Engineering" style="margin-right: 8px;">
                        Engineering
                    </label>
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="Quality" style="margin-right: 8px;">
                        Quality
                    </label>
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="Production" style="margin-right: 8px;">
                        Production
                    </label>
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="Maintenance" style="margin-right: 8px;">
                        Maintenance
                    </label>
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="IT" style="margin-right: 8px;">
                        IT
                    </label>
                    <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" class="dept-checkbox" value="Other" style="margin-right: 8px;">
                        Other
                    </label>
                </div>

                <div style="margin-top: 15px;">
                    <label>Due Date (Optional)</label>
                    <input type="datetime-local" id="requestDueDate"
                        style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;">
                </div>
            </div>

            <!-- Submit Button -->
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeCreateQuestionModal()" 
                    style="padding: 10px 20px; border: 1px solid #ccc; background: white; color: #333; border-radius: 4px; cursor: pointer;">
                    Cancel
                </button>
                <button onclick="submitQuestion()" 
                    style="padding: 10px 20px; border: none; background: #017374; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">
                    Submit to Staging Ground
                </button>
            </div>
        </div>
    </div>

    <style>
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        [data-theme="dark"] .modal-content {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        [data-theme="dark"] .modal-content input,
        [data-theme="dark"] .modal-content textarea {
            background-color: #2d2d2d;
            color: #e0e0e0;
            border-color: #444;
        }

        [data-theme="dark"] .modal-content label[style*="border"] {
            border-color: #444 !important;
            background-color: #2d2d2d;
        }

        .modal-close {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
        }

        .modal-close:hover {
            color: #333;
        }

        .verification-type-btn.active {
            background: #017374 !important;
            color: white !important;
            border-color: #017374 !important;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
        }
    </style>
</body>
</html>
